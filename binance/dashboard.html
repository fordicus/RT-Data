<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta
		name="viewport"
		content="width=device-width, initial-scale=1.0"
	>
	<title>Stream Binance Dashboard</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			margin: 20px;
		}
		table {
			width: 100%;
			border-collapse: collapse;
			margin-bottom: 20px;
		}
		th, td {
			border: 1px solid #ddd;
			padding: 8px;
			text-align: center;
		}
		th {
			background-color: #f4f4f4;
		}
		tr:nth-child(even) {
			background-color: #f9f9f9;
		}
		#lastUpdated {
			margin-top: 10px;
			font-size: 14px;
			color: #555;
		}
		.section-title {
			margin-top: 30px;
			margin-bottom: 10px;
			font-size: 18px;
			font-weight: bold;
		}
	</style>
</head>
<body>
	<h1>Binance Dashboard</h1>
	<div
		id="statusInfo"
		style="margin-top: 10px; font-size: 14px; color: #555;"
	>
		WebSocket Peer: N/A / Last Updated: N/A
	</div>
	<div id="lastUpdated">Last Updated: N/A</div>

	<div class="section-title">Hardware Metrics</div>
	<table id="hardwareMetricsTable">
		<thead>
			<tr>
				<th>Metric</th>
				<th>Value</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>Network Usage</td>
				<td id="networkUsage">0 Mbps</td>
			</tr>
			<tr>
				<td>CPU Usage</td>
				<td id="cpuUsage">0.0%</td>
			</tr>
			<tr>
				<td>Memory Usage</td>
				<td id="memoryUsage">0.0%</td>
			</tr>
			<tr>
				<td>Storage Usage</td>
				<td id="storageUsage">0.0%</td>
			</tr>
		</tbody>
	</table>

	<div class="section-title">Symbol Metrics</div>
	<table id="symbolMetricsTable">
		<thead>
			<tr>
				<th>#</th>
				<th>Symbol</th>
				<th>
					Put Snapshot Interval<br>Avg.: 0 [ms]
				</th>
				<th>
					JSON Flush Interval<br>Avg.: 0 [ms]
				</th>
				<th id="queueSizeHeader">
					Queue Size<br>Total: 0
				</th>
				<th>
					Mean Latency<br>Avg.: 0 [ms]
				</th>
			</tr>
		</thead>
		<tbody>
			<!-- Rows will be dynamically added here -->
		</tbody>
	</table>
	<div
		id="symbolMetricsDescription"
		style="
			margin-bottom: 15px;
			font-size: 14px;
			color: #555;
			line-height: 1.4;
		"
	></div>

	<!-- ———————————————————————————————————————————————— -->
	<script>
	// @ts-check

	/** Types for hardware metrics. */
	/**
	 * @typedef {Object} HardwareMetrics
	 * @property {number} network_mbps
	 * @property {number} cpu_percent
	 * @property {number} memory_percent
	 * @property {number} storage_percent
	 */

	/** Types for dashboard payload. */
	/**
	 * @typedef {Object} DashboardData
	 * @property {string=} websocket_peer
	 * @property {(string|number|Date)=} last_updated
	 * @property {HardwareMetrics=} hardware
	 * @property {Record<string, number>} snapshot_interval
	 * @property {Record<string, number>} flush_interval
	 * @property {Record<string, number>} med_latency
	 * @property {Record<string, number>} queue_size
	 */

	/** Query selector alias (nullable). */
	/** @param {string} selector */
	function querySelectorAlias(selector) {
		return document.querySelector(selector);
	}

	/** Get element by id with fallback span. */
	/**
	 * @template {HTMLElement} T
	 * @param {string} id
	 * @returns {T}
	 */
	function byId(id) {
		/** @type {T|null} */
		// @ts-ignore generic inference at runtime
		const el = document.getElementById(id);
		if (!el) {
			const fallback = document.createElement("span");
			fallback.id = id;
			document.body.appendChild(fallback);
			// @ts-ignore explicit cast for runtime
			return /** @type {T} */ (fallback);
		}
		// @ts-ignore explicit cast for runtime
		return /** @type {T} */ (el);
	}

	/** Static rich description for symbol metrics. */
	const SYMBOL_METRICS_DESCRIPTION =
		"<strong>Put Snapshot Interval:</strong> " +
		"The measured interval between consecutive " +
		"\"asyncio.Queue.put()\" operations within the " +
		"\"put_snapshot()\" coroutine. Any extra delay beyond the " +
		"nominal 100ms streaming interval determines \"intv_lag_ms\", " +
		"which is used as side information during AI training.<br>" +
		"<strong>JSON Flush Interval:</strong> The measured interval " +
		"between consecutive \"TextIOWrapper.flush()\" operations to " +
		"disk. This value does not affect the timestamps written to " +
		"\".jsonl\" files, as it only reflects disk I/O latency after " +
		"\"recv_ms\" is determined by the \"put_snapshot()\" " +
		"coroutine.<br>" +
		"<strong>Queue Size:</strong> The average of " +
		"\"asyncio.Queue.qsize()\" values over a monitoring period. " +
		"This value is typically close to zero, as the " +
		"\"asyncio.Queue\" is consumed almost instantaneously.<br>" +
		"<strong>Mean Latency:</strong> The mean one-way network " +
		"latency from Binance servers, calculated over a sampling " +
		"period. This estimate defines \"net_delay_ms\", which—like " +
		"\"intv_lag_ms\"—serves as side information for AI models.";

	/** Build ws scheme based on page protocol. */
	const wsScheme = location.protocol === "https:" ? "wss" : "ws";
	const wsUrl = wsScheme + "://" + location.host + "/ws/dashboard";
	const ws = new WebSocket(wsUrl);

	ws.onopen = () => {
		console.log("WebSocket connection established.");
		/** @type {HTMLDivElement} */
		(byId("symbolMetricsDescription")).innerHTML =
			SYMBOL_METRICS_DESCRIPTION;
	};

	/** Handle incoming dashboard payload. */
	/** @param {MessageEvent<string>} event */
	ws.onmessage = (event) => {
		/** @type {DashboardData} */
		let data;
		try {
			data = /** @type {DashboardData} */
				(JSON.parse(event.data));
		} catch (e) {
			console.error("Invalid JSON payload:", e);
			return;
		}

		const peer = data.websocket_peer ?? "UNKNOWN";
		const lastIso =
			data.last_updated != null
				? new Date(data.last_updated).toISOString()
				: "N/A";

		/** @type {HTMLDivElement} */
		(byId("statusInfo")).textContent =
			"WebSocket Peer: " + peer + " / Last Updated: " + lastIso;

		if (data.hardware) {
			const hw = data.hardware;
			/** @type {HTMLTableCellElement} */
			(byId("networkUsage")).textContent =
				hw.network_mbps.toFixed(2) + " Mbps";
			/** @type {HTMLTableCellElement} */
			(byId("cpuUsage")).textContent =
				hw.cpu_percent.toFixed(2) + "%";
			/** @type {HTMLTableCellElement} */
			(byId("memoryUsage")).textContent =
				hw.memory_percent.toFixed(2) + "%";
			/** @type {HTMLTableCellElement} */
			(byId("storageUsage")).textContent =
				hw.storage_percent.toFixed(2) + "%";
		}

		let snapSum = 0;
		let flushSum = 0;
		let latSum = 0;
		let snapCnt = 0;
		let flushCnt = 0;
		let latCnt = 0;
		let queueTotal = 0;

		for (const s in data.snapshot_interval) {
			snapSum += data.snapshot_interval[s];
			snapCnt++;
		}
		const snapAvg =
			snapCnt > 0 ? (snapSum / snapCnt).toFixed(2) : "0";

		for (const s in data.flush_interval) {
			flushSum += data.flush_interval[s];
			flushCnt++;
		}
		const flushAvg =
			flushCnt > 0 ? (flushSum / flushCnt).toFixed(2) : "0";

		for (const s in data.med_latency) {
			latSum += data.med_latency[s];
			latCnt++;
		}
		const latAvg =
			latCnt > 0 ? (latSum / latCnt).toFixed(2) : "0";

		/** @type {HTMLTableSectionElement|null} */
		const tbody =
			/** @type {any} */
			(querySelectorAlias("#symbolMetricsTable tbody"));
		if (tbody) {
			tbody.innerHTML = "";
			let rowIndex = 1;
			for (const s in data.med_latency) {
				const tr = document.createElement("tr");

				const nCell = document.createElement("td");
				nCell.textContent = String(rowIndex++);

				const symCell = document.createElement("td");
				symCell.textContent = s.toUpperCase();

				const snapCell = document.createElement("td");
				snapCell.textContent =
					String(data.snapshot_interval[s] ?? 0);

				const flushCell = document.createElement("td");
				flushCell.textContent =
					String(data.flush_interval[s] ?? 0);

				const qCell = document.createElement("td");
				const qVal = data.queue_size[s] ?? 0;
				qCell.textContent = String(qVal);

				const latCell = document.createElement("td");
				latCell.textContent =
					String(data.med_latency[s] ?? 0);

				queueTotal += qVal;

				tr.appendChild(nCell);
				tr.appendChild(symCell);
				tr.appendChild(snapCell);
				tr.appendChild(flushCell);
				tr.appendChild(qCell);
				tr.appendChild(latCell);
				tbody.appendChild(tr);
			}
		}

		/** @type {HTMLTableRowElement|null} */
		const headRow =
			/** @type {any} */
			(querySelectorAlias("#symbolMetricsTable thead tr"));
		if (headRow) {
			headRow.innerHTML =
				"<th>#</th>" +
				"<th>Symbol</th>" +
				"<th>Put Snapshot Interval<br>" +
				"Avg.: " + snapAvg + " [ms]</th>" +
				"<th>JSON Flush Interval<br>" +
				"Avg.: " + flushAvg + " [ms]</th>" +
				"<th id=\"queueSizeHeader\">Queue Size<br>" +
				"Total: " + queueTotal + "</th>" +
				"<th>Mean Latency<br>" +
				"Avg.: " + latAvg + " [ms]</th>";
		}

		/** @type {HTMLDivElement|null} */
		const lastEl =
			/** @type {any} */
			(querySelectorAlias("#lastUpdated"));
		if (lastEl) {
			const formatted =
				lastIso !== "N/A"
					? new Date(lastIso).toISOString()
						.slice(0, 19) + "Z"
					: "N/A";
			lastEl.textContent = "Last Updated: " + formatted;
		}
	};

	ws.onerror = (error) => {
		console.error("WebSocket error:", error);
	};

	ws.onclose = () => {
		console.log("WebSocket connection closed.");
	};
	</script>
</body>
</html>
